<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/../HSTempoWasm.Tests/HSTempoWasm.Tests.csproj">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/../HSTempoWasm.Tests/HSTempoWasm.Tests.csproj" />
              <option name="updatedContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;&#10;  &lt;PropertyGroup&gt;&#10;    &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;&#10;    &lt;IsPackable&gt;false&lt;/IsPackable&gt;&#10;  &lt;/PropertyGroup&gt;&#10;  &lt;ItemGroup&gt;&#10;    &lt;PackageReference Include=&quot;xunit&quot; Version=&quot;2.4.2&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;xunit.runner.visualstudio&quot; Version=&quot;2.4.5&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.NET.Test.Sdk&quot; Version=&quot;17.9.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;FluentAssertions&quot; Version=&quot;6.13.0&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;  &lt;ItemGroup&gt;&#10;    &lt;ProjectReference Include=&quot;..\HSTempoWasm\HSTempoWasm.csproj&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;&lt;/Project&gt;&#10;// ...existing code...&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/../HSTempoWasm.sln">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/../HSTempoWasm.sln" />
              <option name="updatedContent" value="// ...existing code...&#10;Project(&quot;{9A19103F-16F7-4668-BE54-9A1E7A4F7556}&quot;) = &quot;HSTempoWasm.Tests&quot;, &quot;HSTempoWasm.Tests\HSTempoWasm.Tests.csproj&quot;, &quot;{B1B2B3B4-B5B6-B7B8-B9BA-BBBBBBBBBBBB}&quot;&#10;EndProject&#10;// ...existing code...&#10;&#9;{B1B2B3B4-B5B6-B7B8-B9BA-BBBBBBBBBBBB}.Debug|Any CPU.ActiveCfg = Debug|Any CPU&#10;&#9;{B1B2B3B4-B5B6-B7B8-B9BA-BBBBBBBBBBBB}.Debug|Any CPU.Build.0 = Debug|Any CPU&#10;&#9;{B1B2B3B4-B5B6-B7B8-B9BA-BBBBBBBBBBBB}.Release|Any CPU.ActiveCfg = Release|Any CPU&#10;&#9;{B1B2B3B4-B5B6-B7B8-B9BA-BBBBBBBBBBBB}.Release|Any CPU.Build.0 = Release|Any CPU&#10;// ...existing code...&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/HSTempoWasm.Tests/HSTempoWasm.Tests.csproj">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/HSTempoWasm.Tests/HSTempoWasm.Tests.csproj" />
              <option name="updatedContent" value="&lt;Project Sdk=&quot;Microsoft.NET.Sdk&quot;&gt;&#10;  &lt;PropertyGroup&gt;&#10;    &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;&#10;    &lt;IsPackable&gt;false&lt;/IsPackable&gt;&#10;  &lt;/PropertyGroup&gt;&#10;  &lt;ItemGroup&gt;&#10;    &lt;PackageReference Include=&quot;xunit&quot; Version=&quot;2.4.2&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;xunit.runner.visualstudio&quot; Version=&quot;2.4.5&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;Microsoft.NET.Test.Sdk&quot; Version=&quot;17.9.0&quot; /&gt;&#10;    &lt;PackageReference Include=&quot;FluentAssertions&quot; Version=&quot;6.13.0&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;  &lt;ItemGroup&gt;&#10;    &lt;ProjectReference Include=&quot;..\HSTempoWasm.csproj&quot; /&gt;&#10;  &lt;/ItemGroup&gt;&#10;&lt;/Project&gt;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/HSTempoWasm.Tests/TempoLogicTests.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/HSTempoWasm.Tests/TempoLogicTests.cs" />
              <option name="originalContent" value="using Xunit;&#10;using FluentAssertions;&#10;&#10;namespace HSTempoWasm.Tests&#10;{&#10;    using System;&#10;&#10;    public class TempoLogicTests&#10;    {&#10;        [Theory]&#10;        [InlineData(120, 500)]&#10;        [InlineData(60, 1000)]&#10;        [InlineData(0, 0)]&#10;        public void CalculateBPMtoMS_ReturnsExpectedMilliseconds(int bpm, short expectedMs)&#10;        {&#10;            // Arrange&#10;            var tempo = new TestableTempo { CurrentBpm = bpm };&#10;&#10;            // Act&#10;            var result = tempo.CalculateBPMtoMS();&#10;&#10;            // Assert&#10;            result.Should().Be(expectedMs);&#10;        }&#10;    }&#10;&#10;    // テスト用のTempoクラス（必要な部分のみ抜粋）&#10;    public class TestableTempo&#10;    {&#10;        public double CurrentBpm { get; set; }&#10;        public short CalculateBPMtoMS()&#10;        {&#10;            return CurrentBpm &lt;= 0 ? (short)0 : Convert.ToInt16(Math.Round(60000 / CurrentBpm));&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="using Xunit;&#10;using FluentAssertions;&#10;using HSTempoWasm;&#10;&#10;namespace HSTempoWasm.Tests&#10;{&#10;    public class TempoLogicTests&#10;    {&#10;        [Theory]&#10;        [InlineData(120, 500)]&#10;        [InlineData(60, 1000)]&#10;        [InlineData(0, 0)]&#10;        public void CalculateBPMtoMS_ReturnsExpectedMilliseconds(double bpm, short expectedMs)&#10;        {&#10;            // Act&#10;            var result = TempoLogic.CalculateBPMtoMS(bpm);&#10;&#10;            // Assert&#10;            result.Should().Be(expectedMs);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Pages/Tempo.razor.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Pages/Tempo.razor.cs" />
              <option name="originalContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using System.Text.Json;&#10;using System.Text.Json.Serialization;&#10;using System.Threading.Tasks;&#10;using System.Timers;&#10;using Fluxor;&#10;using HSTempoWasm.Store.AudibleBeat;&#10;using HSTempoWasm.Store.VBI;&#10;using Microsoft.AspNetCore.Components;&#10;using Microsoft.AspNetCore.Components.Web;&#10;using Microsoft.JSInterop;&#10;&#10;namespace HSTempoWasm.Pages&#10;{&#10;    public partial class Tempo&#10;    {&#10;        // Fields (no redundant initialization)&#10;        private int currentCount;&#10;        private int elapsedSecond;&#10;        private double currentBpm;&#10;&#10;        // Constants for BPM array sizes&#10;        private const int BpmArraySize10 = 10;&#10;        private const int BpmArraySize15 = 15;&#10;        private const int BpmArraySize20 = 20;&#10;&#10;        // BPM values and averages&#10;        private double[] bpmValues10 = new double[BpmArraySize10];&#10;        private double[] bpmValues15 = new double[BpmArraySize15];&#10;        private double[] bpmValues20 = new double[BpmArraySize20];&#10;&#10;        private string bpmAverage10 = &quot;X&quot;;&#10;        private string bpmAverage15 = &quot;X&quot;;&#10;        private string bpmAverage20 = &quot;X&quot;;&#10;&#10;        private int bpmIndex10;&#10;        private int bpmIndex15;&#10;        private int bpmIndex20;&#10;&#10;        // Timing and calculation fields&#10;        private int averageMs;&#10;        private int bpmInterval;&#10;        private int jitter;&#10;        private double stability;&#10;&#10;        // Styles&#10;        private const string VbiInactiveStyle = &quot;btn btn-dark&quot;;&#10;        private const string VbiActiveStyle = &quot;btn btn-success&quot;;&#10;&#10;        // Time tracking&#10;        private DateTime currentTime;&#10;        private DateTime startTime;&#10;        private DateTime lastTime;&#10;        private double recentTimeMs;&#10;&#10;        // Meter mode&#10;        private string meterBoxMode = &quot;VBI&quot;;&#10;        private int meterBoxModeNumeric = 1;&#10;&#10;        // UI references&#10;        private ElementReference beatButton;&#10;&#10;        // State injection (nullable for safety)&#10;        [Inject] public IDispatcher? Dispatcher { get; set; }&#10;        [Inject] private IState&lt;AudibleState&gt;? AudibleState { get; set; }&#10;        [Inject] private IState&lt;VBIState&gt;? VbiState { get; set; }&#10;&#10;        private async Task InitializeFocus()&#10;        {&#10;            await beatButton.FocusAsync();&#10;        }&#10;&#10;        protected override void OnAfterRender(bool firstRender)&#10;        {&#10;            if (firstRender)&#10;            {&#10;                InitializeFocus();&#10;            }&#10;        }&#10;&#10;        private string vbi1 = VbiInactiveStyle;&#10;        private string vbi2 = VbiInactiveStyle;&#10;        private string vbi3 = VbiInactiveStyle;&#10;        private string vbi4 = VbiInactiveStyle;&#10;&#10;        void UpdateVbi(int mode)&#10;        {&#10;            switch (mode)&#10;            {&#10;                case 0:&#10;                {&#10;                    vbi1 = VbiInactiveStyle;&#10;                    vbi2 = VbiInactiveStyle;&#10;                    vbi3 = VbiInactiveStyle;&#10;                    vbi4 = VbiInactiveStyle;&#10;                    break;&#10;                }&#10;                case 1:&#10;                {&#10;                    vbi1 = VbiActiveStyle;&#10;                    vbi2 = VbiInactiveStyle;&#10;                    vbi3 = VbiInactiveStyle;&#10;                    vbi4 = VbiInactiveStyle;&#10;                    break;&#10;                }&#10;                case 2:&#10;                {&#10;                    vbi1 = VbiInactiveStyle;&#10;                    vbi2 = VbiActiveStyle;&#10;                    vbi3 = VbiInactiveStyle;&#10;                    vbi4 = VbiInactiveStyle;&#10;                    break;&#10;                }&#10;                case 3:&#10;                {&#10;                    vbi1 = VbiInactiveStyle;&#10;                    vbi2 = VbiInactiveStyle;&#10;                    vbi3 = VbiActiveStyle;&#10;                    vbi4 = VbiInactiveStyle;&#10;                    break;&#10;                }&#10;                case 4:&#10;                {&#10;                    vbi1 = VbiInactiveStyle;&#10;                    vbi2 = VbiInactiveStyle;&#10;                    vbi3 = VbiInactiveStyle;&#10;                    vbi4 = VbiActiveStyle;&#10;                    break;&#10;                }&#10;                case 5:&#10;                {&#10;                    vbi1 = VbiActiveStyle;&#10;                    vbi2 = VbiActiveStyle;&#10;                    vbi3 = VbiActiveStyle;&#10;                    vbi4 = VbiActiveStyle;&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;&#10;        // Fix GetKeyPress to async&#10;        async void GetKeyPress(KeyboardEventArgs e)&#10;        {&#10;            switch (e.Key)&#10;            {&#10;                case &quot;r&quot;:&#10;                case &quot;R&quot;:&#10;                {&#10;                    await Reset();&#10;                    break;&#10;                }&#10;&#10;                case &quot;b&quot;:&#10;                case &quot;B&quot;:&#10;                {&#10;                    await InitializeFocus();&#10;                    break;&#10;                }&#10;&#10;                case &quot;u&quot;:&#10;                case &quot;U&quot;:&#10;                {&#10;                    AdjustUp();&#10;                    break;&#10;                }&#10;&#10;                case &quot;d&quot;:&#10;                case &quot;D&quot;:&#10;                {&#10;                    AdjustDown();&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;&#10;&#10;        private class MetricInfo&#10;        {&#10;            [JsonPropertyName(&quot;elapsed&quot;)] public TimeSpan Elapsed { get; set; }&#10;            [JsonPropertyName(&quot;count&quot;)] public int Count { get; set; }&#10;            [JsonPropertyName(&quot;measured_bpm&quot;)] public int MeasuredBpm { get; set; }&#10;            [JsonPropertyName(&quot;ms&quot;)] public int Ms { get; set; }&#10;            [JsonPropertyName(&quot;jitter&quot;)] public int Jitter { get; set; }&#10;        }&#10;&#10;        private class Record&#10;        {&#10;            [JsonPropertyName(&quot;average_bpm&quot;)] public int AverageBpm { get; set; }&#10;            [JsonPropertyName(&quot;average_ms&quot;)] public int AverageMs { get; set; }&#10;            [JsonPropertyName(&quot;metric&quot;)] public List&lt;MetricInfo&gt; Metric { get; set; }&#10;        }&#10;&#10;        private Record? sessionRecord;&#10;&#10;        private void ExecBeat()&#10;        {&#10;            currentTime = DateTime.Now;&#10;            var accumulatedMs = currentTime - startTime;&#10;            currentBpm = Math.Round((currentCount / accumulatedMs.TotalMilliseconds) * 60000);&#10;            currentCount++;&#10;&#10;            if (Timers.BeatTimer == null || Timers.BeatTimer.Enabled != true)&#10;            {&#10;                sessionRecord = new Record();&#10;                sessionRecord.Metric = new List&lt;MetricInfo&gt;();&#10;                StartTimer();&#10;            }&#10;&#10;            if (currentCount &gt; 1)&#10;            {&#10;                recentTimeMs = UpdateRecentTime().TotalMilliseconds;&#10;                Timers.VdiTock.Enabled = false;&#10;                Timers.VdiTick.Interval = 60000 / currentBpm;&#10;                Timers.VdiTock.Interval = 60000 / currentBpm / 3;&#10;                Timers.VdiTick.Enabled = true;&#10;                bpmInterval = CalculateBPMtoMS();&#10;                averageMs = (int) (accumulatedMs.TotalMilliseconds / currentCount);&#10;                // Calculate jitter&#10;                jitter = (int) Math.Abs(averageMs - bpmInterval);&#10;&#10;                bpmValues10[bpmIndex10] = currentBpm;&#10;                bpmIndex10++;&#10;                if (bpmIndex10 &gt; BpmArraySize10 - 1)&#10;                    bpmIndex10 = 0;&#10;&#10;                bpmValues15[bpmIndex15] = currentBpm;&#10;                bpmIndex15++;&#10;                if (bpmIndex15 &gt; BpmArraySize15 - 1)&#10;                    bpmIndex15 = 0;&#10;&#10;                bpmValues20[bpmIndex20] = currentBpm;&#10;                bpmIndex20++;&#10;                if (bpmIndex20 &gt; BpmArraySize20 - 1)&#10;                    bpmIndex20 = 0;&#10;&#10;                double bpmAverageValue10 = 0, bpmAverageValue15 = 0, bpmAverageValue20 = 0;&#10;&#10;                if (currentCount &gt; BpmArraySize10)&#10;                {&#10;                    bpmAverageValue10 = Math.Round(bpmValues10.Sum() / BpmArraySize10);&#10;                    bpmAverage10 = bpmAverageValue10.ToString();&#10;                }&#10;&#10;                if (currentCount &gt; BpmArraySize15)&#10;                {&#10;                    bpmAverageValue15 = Math.Round(bpmValues15.Sum() / BpmArraySize15);&#10;                    bpmAverage15 = bpmAverageValue15.ToString();&#10;                }&#10;&#10;                if (currentCount &gt; BpmArraySize20)&#10;                {&#10;                    bpmAverageValue20 = Math.Round(bpmValues20.Sum() / BpmArraySize20);&#10;                    bpmAverage20 = bpmAverageValue20.ToString();&#10;                    stability = (20 - Math.Abs(currentBpm -&#10;                                               (bpmAverageValue10 + bpmAverageValue15 + bpmAverageValue20) / 3)) / 20 *&#10;                                100;&#10;                }&#10;&#10;                sessionRecord.AverageBpm = (int) currentBpm;&#10;                sessionRecord.AverageMs = (int) averageMs;&#10;&#10;                var newMetric = new MetricInfo&#10;                {&#10;                    MeasuredBpm = (int) currentBpm,&#10;                    Count = (int) currentCount,&#10;                    Elapsed = new TimeSpan(0, 0, elapsedSecond),&#10;                    Ms = (int) recentTimeMs,&#10;                    Jitter = (int) jitter&#10;                };&#10;&#10;                sessionRecord.Metric.Add(newMetric);&#10;            }&#10;            else&#10;            {&#10;                Timers.VdiTick = new Timer();&#10;                Timers.VdiTock = new Timer();&#10;                Timers.VdiTick.Elapsed += ProcessTick;&#10;                Timers.VdiTick.AutoReset = true;&#10;                Timers.VdiTock.Elapsed += ProcessTock;&#10;            }&#10;&#10;            lastTime = currentTime;&#10;            Dispatcher.Dispatch(new VBIResetAction());&#10;            UpdateVbi(VbiState.Value.VBIStateNumber);&#10;        }&#10;&#10;        private short CalculateBPMtoMS()&#10;        {&#10;            return currentBpm &lt;= 0 ? (short) 0 : Convert.ToInt16(Math.Round(60000 / currentBpm));&#10;        }&#10;&#10;&#10;        private async Task DownloadJson()&#10;        {&#10;            var result = GenerateMetricJson();&#10;            if (result != null)&#10;            {&#10;                var bytes = System.Text.Encoding.UTF8.GetBytes(result);&#10;                await SaveAs(JSRuntime, &quot;result.json&quot;, bytes);&#10;            }&#10;        }&#10;&#10;        private string GenerateMetricJson()&#10;        {&#10;            return sessionRecord != null ? JsonSerializer.Serialize(sessionRecord) : null;&#10;        }&#10;&#10;        public async static Task SaveAs(IJSRuntime js, string filename, byte[] data)&#10;        {&#10;            await js.InvokeAsync&lt;object&gt;(&#10;                &quot;saveAsFile&quot;,&#10;                filename,&#10;                Convert.ToBase64String(data));&#10;        }&#10;&#10;        private void Rebase()&#10;        {&#10;            if (Timers.BeatTimer != null &amp;&amp; Timers.BeatTimer.Enabled &amp;&amp; currentBpm &gt; 0)&#10;            {&#10;                Dispatcher.Dispatch(new VBIResetAction());&#10;                UpdateVbi(VbiState.Value.VBIStateNumber);&#10;                Timers.VdiTick.Enabled = false;&#10;                Timers.VdiTock.Enabled = false;&#10;                Timers.VdiTick.Enabled = true;&#10;            }&#10;        }&#10;&#10;        private void AdjustUp()&#10;        {&#10;            if (Timers.BeatTimer != null &amp;&amp; Timers.BeatTimer.Enabled &amp;&amp; currentBpm &gt; 0)&#10;            {&#10;                Timers.VdiTick.Enabled = false;&#10;                Timers.VdiTock.Enabled = false;&#10;                currentBpm++;&#10;                Timers.VdiTick.Interval = 60000 / currentBpm;&#10;                Timers.VdiTock.Interval = 60000 / currentBpm / 3;&#10;                Timers.VdiTick.Enabled = true;&#10;                bpmInterval = CalculateBPMtoMS();&#10;            }&#10;        }&#10;&#10;        private void AdjustDown()&#10;        {&#10;            if (Timers.BeatTimer == null || !Timers.BeatTimer.Enabled || !(currentBpm &gt; 0)) return;&#10;            Timers.VdiTick.Enabled = false;&#10;            Timers.VdiTock.Enabled = false;&#10;            currentBpm--;&#10;            Timers.VdiTick.Interval = 60000 / currentBpm;&#10;            Timers.VdiTock.Interval = 60000 / currentBpm / 3;&#10;            Timers.VdiTick.Enabled = true;&#10;            bpmInterval = CalculateBPMtoMS();&#10;        }&#10;&#10;        // Event handler nullability&#10;        private void ProcessTock(object? sender, ElapsedEventArgs e)&#10;        {&#10;            Dispatcher?.Dispatch(new VBITock(meterBoxModeNumeric));&#10;            Timers.VdiTock.Enabled = false;&#10;            UpdateVbi(VbiState?.Value.VBIStateNumber ?? 0);&#10;            this.StateHasChanged();&#10;        }&#10;&#10;        private TimeSpan UpdateRecentTime()&#10;        {&#10;            return currentTime - lastTime;&#10;        }&#10;&#10;        private void TestBeat()&#10;        {&#10;            JSRuntime.InvokeVoidAsync(&quot;playBeat&quot;);&#10;        }&#10;&#10;        // Event handler nullability&#10;        private void ProcessTick(object? sender, ElapsedEventArgs elapsedEventArgs)&#10;        {&#10;            if (AudibleState?.Value.Audible == true)&#10;            {&#10;                JSRuntime.InvokeVoidAsync(&quot;playBeat&quot;);&#10;            }&#10;            Dispatcher?.Dispatch(new VBITick(meterBoxModeNumeric));&#10;            UpdateVbi(VbiState?.Value.VBIStateNumber ?? 0);&#10;            this.StateHasChanged();&#10;            Timers.VdiTock.Enabled = true;&#10;        }&#10;&#10;        private async Task Reset()&#10;        {&#10;            StopTimer();&#10;&#10;            if (Timers.VdiTick != null)&#10;            {&#10;                Timers.VdiTick.Enabled = false;&#10;                Timers.VdiTick.Close();&#10;            }&#10;&#10;            if (Timers.VdiTock != null)&#10;            {&#10;                Timers.VdiTock.Enabled = false;&#10;                Timers.VdiTock.Close();&#10;            }&#10;&#10;            Dispatcher.Dispatch(new ResetAudible());&#10;            Dispatcher.Dispatch(new VBIResetAction());&#10;            UpdateVbi(VbiState.Value.VBIStateNumber);&#10;&#10;            currentCount = 0;&#10;            averageMs = 0;&#10;            bpmInterval = 0;&#10;            jitter = 0;&#10;&#10;            stability = 0;&#10;            bpmAverage10 = &quot;X&quot;;&#10;            bpmAverage15 = &quot;X&quot;;&#10;            bpmAverage20 = &quot;X&quot;;&#10;            await beatButton.FocusAsync();&#10;        }&#10;&#10;        private void StartTimer()&#10;        {&#10;            startTime = DateTime.Now;&#10;            Timers.BeatTimer = new Timer&#10;            {&#10;                Interval = 1000,&#10;                AutoReset = true&#10;            };&#10;            Timers.BeatTimer.Elapsed += ProcessSecond;&#10;            Timers.BeatTimer.Enabled = true;&#10;        }&#10;&#10;        private void ProcessSecond(object? sender, ElapsedEventArgs elapsedEventArgs)&#10;        {&#10;            elapsedSecond++;&#10;            StateHasChanged();&#10;        }&#10;&#10;        private void StopTimer()&#10;        {&#10;            if (Timers.BeatTimer != null &amp;&amp; Timers.BeatTimer.Enabled)&#10;            {&#10;                Timers.BeatTimer.Enabled = false;&#10;                Timers.BeatTimer.Stop();&#10;                Timers.BeatTimer.Close();&#10;            }&#10;&#10;            elapsedSecond = 0;&#10;            currentBpm = 0;&#10;            recentTimeMs = 0;&#10;        }&#10;&#10;        private void ToggleAudibleCheck()&#10;        {&#10;            Dispatcher.Dispatch(new ToggleAudible());&#10;            InvokeAsync(StateHasChanged);&#10;        }&#10;&#10;&#10;        private async Task HandleMeterUpdate(ChangeEventArgs arg)&#10;        {&#10;            meterBoxMode = (string) arg.Value;&#10;&#10;            meterBoxModeNumeric = meterBoxMode switch&#10;            {&#10;                &quot;VBI&quot; =&gt; 1,&#10;                &quot;2/4&quot; =&gt; 2,&#10;                &quot;3/4&quot; =&gt; 3,&#10;                &quot;4/4&quot; =&gt; 4,&#10;                _ =&gt; meterBoxModeNumeric&#10;            };&#10;&#10;            Dispatcher.Dispatch(new VBIResetAction());&#10;            UpdateVbi(VbiState.Value.VBIStateNumber);&#10;            await Task.CompletedTask;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="using System;&#10;using System.Collections.Generic;&#10;using System.Linq;&#10;using System.Text.Json;&#10;using System.Text.Json.Serialization;&#10;using System.Threading.Tasks;&#10;using System.Timers;&#10;using Fluxor;&#10;using HSTempoWasm.Store.AudibleBeat;&#10;using HSTempoWasm.Store.VBI;&#10;using Microsoft.AspNetCore.Components;&#10;using Microsoft.AspNetCore.Components.Web;&#10;using Microsoft.JSInterop;&#10;&#10;namespace HSTempoWasm.Pages&#10;{&#10;    public partial class Tempo&#10;    {&#10;        // Fields (no redundant initialization)&#10;        private int currentCount;&#10;        private int elapsedSecond;&#10;        private double currentBpm;&#10;        private int averageMs;&#10;&#10;        // Constants for BPM array sizes&#10;        private const int BpmArraySize10 = 10;&#10;        private const int BpmArraySize15 = 15;&#10;        private const int BpmArraySize20 = 20;&#10;&#10;        // BPM values and averages&#10;        private double[] bpmValues10 = new double[BpmArraySize10];&#10;        private double[] bpmValues15 = new double[BpmArraySize15];&#10;        private double[] bpmValues20 = new double[BpmArraySize20];&#10;&#10;        private string bpmAverage10 = &quot;X&quot;;&#10;        private string bpmAverage15 = &quot;X&quot;;&#10;        private string bpmAverage20 = &quot;X&quot;;&#10;&#10;        private int bpmIndex10;&#10;        private int bpmIndex15;&#10;        private int bpmIndex20;&#10;&#10;        // Timing and calculation fields&#10;        private int bpmInterval;&#10;        private int jitter;&#10;        private double stability;&#10;&#10;        // Styles&#10;        private const string VbiInactiveStyle = &quot;btn btn-dark&quot;;&#10;        private const string VbiActiveStyle = &quot;btn btn-success&quot;;&#10;&#10;        // Time tracking&#10;        private DateTime currentTime;&#10;        private DateTime startTime;&#10;        private DateTime lastTime;&#10;        private double recentTimeMs;&#10;&#10;        // Meter mode&#10;        private string meterBoxMode = &quot;VBI&quot;;&#10;        private int meterBoxModeNumeric = 1;&#10;&#10;        // UI references&#10;        private ElementReference beatButton;&#10;&#10;        // State injection (nullable for safety)&#10;        [Inject] public IDispatcher? Dispatcher { get; set; }&#10;        [Inject] private IState&lt;AudibleState&gt;? AudibleState { get; set; }&#10;        [Inject] private IState&lt;VBIState&gt;? VbiState { get; set; }&#10;&#10;        private async Task InitializeFocus()&#10;        {&#10;            await beatButton.FocusAsync();&#10;        }&#10;&#10;        protected override void OnAfterRender(bool firstRender)&#10;        {&#10;            if (firstRender)&#10;            {&#10;                InitializeFocus();&#10;            }&#10;        }&#10;&#10;        private string vbi1 = VbiInactiveStyle;&#10;        private string vbi2 = VbiInactiveStyle;&#10;        private string vbi3 = VbiInactiveStyle;&#10;        private string vbi4 = VbiInactiveStyle;&#10;&#10;        void UpdateVbi(int mode)&#10;        {&#10;            switch (mode)&#10;            {&#10;                case 0:&#10;                {&#10;                    vbi1 = VbiInactiveStyle;&#10;                    vbi2 = VbiInactiveStyle;&#10;                    vbi3 = VbiInactiveStyle;&#10;                    vbi4 = VbiInactiveStyle;&#10;                    break;&#10;                }&#10;                case 1:&#10;                {&#10;                    vbi1 = VbiActiveStyle;&#10;                    vbi2 = VbiInactiveStyle;&#10;                    vbi3 = VbiInactiveStyle;&#10;                    vbi4 = VbiInactiveStyle;&#10;                    break;&#10;                }&#10;                case 2:&#10;                {&#10;                    vbi1 = VbiInactiveStyle;&#10;                    vbi2 = VbiActiveStyle;&#10;                    vbi3 = VbiInactiveStyle;&#10;                    vbi4 = VbiInactiveStyle;&#10;                    break;&#10;                }&#10;                case 3:&#10;                {&#10;                    vbi1 = VbiInactiveStyle;&#10;                    vbi2 = VbiInactiveStyle;&#10;                    vbi3 = VbiActiveStyle;&#10;                    vbi4 = VbiInactiveStyle;&#10;                    break;&#10;                }&#10;                case 4:&#10;                {&#10;                    vbi1 = VbiInactiveStyle;&#10;                    vbi2 = VbiInactiveStyle;&#10;                    vbi3 = VbiInactiveStyle;&#10;                    vbi4 = VbiActiveStyle;&#10;                    break;&#10;                }&#10;                case 5:&#10;                {&#10;                    vbi1 = VbiActiveStyle;&#10;                    vbi2 = VbiActiveStyle;&#10;                    vbi3 = VbiActiveStyle;&#10;                    vbi4 = VbiActiveStyle;&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;&#10;        // Fix GetKeyPress to async&#10;        async void GetKeyPress(KeyboardEventArgs e)&#10;        {&#10;            switch (e.Key)&#10;            {&#10;                case &quot;r&quot;:&#10;                case &quot;R&quot;:&#10;                {&#10;                    await Reset();&#10;                    break;&#10;                }&#10;&#10;                case &quot;b&quot;:&#10;                case &quot;B&quot;:&#10;                {&#10;                    await InitializeFocus();&#10;                    break;&#10;                }&#10;&#10;                case &quot;u&quot;:&#10;                case &quot;U&quot;:&#10;                {&#10;                    AdjustUp();&#10;                    break;&#10;                }&#10;&#10;                case &quot;d&quot;:&#10;                case &quot;D&quot;:&#10;                {&#10;                    AdjustDown();&#10;                    break;&#10;                }&#10;            }&#10;        }&#10;&#10;&#10;        private class MetricInfo&#10;        {&#10;            [JsonPropertyName(&quot;elapsed&quot;)] public TimeSpan Elapsed { get; set; }&#10;            [JsonPropertyName(&quot;count&quot;)] public int Count { get; set; }&#10;            [JsonPropertyName(&quot;measured_bpm&quot;)] public int MeasuredBpm { get; set; }&#10;            [JsonPropertyName(&quot;ms&quot;)] public int Ms { get; set; }&#10;            [JsonPropertyName(&quot;jitter&quot;)] public int Jitter { get; set; }&#10;        }&#10;&#10;        private class Record&#10;        {&#10;            [JsonPropertyName(&quot;average_bpm&quot;)] public int AverageBpm { get; set; }&#10;            [JsonPropertyName(&quot;average_ms&quot;)] public int AverageMs { get; set; }&#10;            [JsonPropertyName(&quot;metric&quot;)] public List&lt;MetricInfo&gt; Metric { get; set; }&#10;        }&#10;&#10;        private Record? sessionRecord;&#10;&#10;        private void ExecBeat()&#10;        {&#10;            currentTime = DateTime.Now;&#10;            var accumulatedMs = currentTime - startTime;&#10;            currentBpm = Math.Round((currentCount / accumulatedMs.TotalMilliseconds) * 60000);&#10;            currentCount++;&#10;&#10;            if (Timers.BeatTimer == null || Timers.BeatTimer.Enabled != true)&#10;            {&#10;                sessionRecord = new Record();&#10;                sessionRecord.Metric = new List&lt;MetricInfo&gt;();&#10;                StartTimer();&#10;            }&#10;&#10;            if (currentCount &gt; 1)&#10;            {&#10;                recentTimeMs = UpdateRecentTime().TotalMilliseconds;&#10;                Timers.VdiTock.Enabled = false;&#10;                Timers.VdiTick.Interval = 60000 / currentBpm;&#10;                Timers.VdiTock.Interval = 60000 / currentBpm / 3;&#10;                Timers.VdiTick.Enabled = true;&#10;                bpmInterval = CalculateBPMtoMS();&#10;                averageMs = (int) (accumulatedMs.TotalMilliseconds / currentCount);&#10;                // Calculate jitter&#10;                jitter = (int) Math.Abs(averageMs - bpmInterval);&#10;&#10;                bpmValues10[bpmIndex10] = currentBpm;&#10;                bpmIndex10++;&#10;                if (bpmIndex10 &gt; BpmArraySize10 - 1)&#10;                    bpmIndex10 = 0;&#10;&#10;                bpmValues15[bpmIndex15] = currentBpm;&#10;                bpmIndex15++;&#10;                if (bpmIndex15 &gt; BpmArraySize15 - 1)&#10;                    bpmIndex15 = 0;&#10;&#10;                bpmValues20[bpmIndex20] = currentBpm;&#10;                bpmIndex20++;&#10;                if (bpmIndex20 &gt; BpmArraySize20 - 1)&#10;                    bpmIndex20 = 0;&#10;&#10;                double bpmAverageValue10 = 0, bpmAverageValue15 = 0, bpmAverageValue20 = 0;&#10;&#10;                if (currentCount &gt; BpmArraySize10)&#10;                {&#10;                    bpmAverageValue10 = Math.Round(bpmValues10.Sum() / BpmArraySize10);&#10;                    bpmAverage10 = bpmAverageValue10.ToString();&#10;                }&#10;&#10;                if (currentCount &gt; BpmArraySize15)&#10;                {&#10;                    bpmAverageValue15 = Math.Round(bpmValues15.Sum() / BpmArraySize15);&#10;                    bpmAverage15 = bpmAverageValue15.ToString();&#10;                }&#10;&#10;                if (currentCount &gt; BpmArraySize20)&#10;                {&#10;                    bpmAverageValue20 = Math.Round(bpmValues20.Sum() / BpmArraySize20);&#10;                    bpmAverage20 = bpmAverageValue20.ToString();&#10;                    stability = (20 - Math.Abs(currentBpm -&#10;                                               (bpmAverageValue10 + bpmAverageValue15 + bpmAverageValue20) / 3)) / 20 *&#10;                                100;&#10;                }&#10;&#10;                sessionRecord.AverageBpm = (int) currentBpm;&#10;                sessionRecord.AverageMs = (int) averageMs;&#10;&#10;                var newMetric = new MetricInfo&#10;                {&#10;                    MeasuredBpm = (int) currentBpm,&#10;                    Count = (int) currentCount,&#10;                    Elapsed = new TimeSpan(0, 0, elapsedSecond),&#10;                    Ms = (int) recentTimeMs,&#10;                    Jitter = (int) jitter&#10;                };&#10;&#10;                sessionRecord.Metric.Add(newMetric);&#10;            }&#10;            else&#10;            {&#10;                Timers.VdiTick = new Timer();&#10;                Timers.VdiTock = new Timer();&#10;                Timers.VdiTick.Elapsed += ProcessTick;&#10;                Timers.VdiTick.AutoReset = true;&#10;                Timers.VdiTock.Elapsed += ProcessTock;&#10;            }&#10;&#10;            lastTime = currentTime;&#10;            Dispatcher.Dispatch(new VBIResetAction());&#10;            UpdateVbi(VbiState.Value.VBIStateNumber);&#10;        }&#10;&#10;        private short CalculateBPMtoMS()&#10;        {&#10;            return currentBpm &lt;= 0 ? (short) 0 : Convert.ToInt16(Math.Round(60000 / currentBpm));&#10;        }&#10;&#10;&#10;        private async Task DownloadJson()&#10;        {&#10;            var result = GenerateMetricJson();&#10;            if (result != null)&#10;            {&#10;                var bytes = System.Text.Encoding.UTF8.GetBytes(result);&#10;                await SaveAs(JSRuntime, &quot;result.json&quot;, bytes);&#10;            }&#10;        }&#10;&#10;        private string GenerateMetricJson()&#10;        {&#10;            return sessionRecord != null ? JsonSerializer.Serialize(sessionRecord) : null;&#10;        }&#10;&#10;        public async static Task SaveAs(IJSRuntime js, string filename, byte[] data)&#10;        {&#10;            await js.InvokeAsync&lt;object&gt;(&#10;                &quot;saveAsFile&quot;,&#10;                filename,&#10;                Convert.ToBase64String(data));&#10;        }&#10;&#10;        private void Rebase()&#10;        {&#10;            if (Timers.BeatTimer != null &amp;&amp; Timers.BeatTimer.Enabled &amp;&amp; currentBpm &gt; 0)&#10;            {&#10;                Dispatcher.Dispatch(new VBIResetAction());&#10;                UpdateVbi(VbiState.Value.VBIStateNumber);&#10;                Timers.VdiTick.Enabled = false;&#10;                Timers.VdiTock.Enabled = false;&#10;                Timers.VdiTick.Enabled = true;&#10;            }&#10;        }&#10;&#10;        private void AdjustUp()&#10;        {&#10;            if (Timers.BeatTimer != null &amp;&amp; Timers.BeatTimer.Enabled &amp;&amp; currentBpm &gt; 0)&#10;            {&#10;                Timers.VdiTick.Enabled = false;&#10;                Timers.VdiTock.Enabled = false;&#10;                currentBpm++;&#10;                Timers.VdiTick.Interval = 60000 / currentBpm;&#10;                Timers.VdiTock.Interval = 60000 / currentBpm / 3;&#10;                Timers.VdiTick.Enabled = true;&#10;                bpmInterval = CalculateBPMtoMS();&#10;            }&#10;        }&#10;&#10;        private void AdjustDown()&#10;        {&#10;            if (Timers.BeatTimer == null || !Timers.BeatTimer.Enabled || !(currentBpm &gt; 0)) return;&#10;            Timers.VdiTick.Enabled = false;&#10;            Timers.VdiTock.Enabled = false;&#10;            currentBpm--;&#10;            Timers.VdiTick.Interval = 60000 / currentBpm;&#10;            Timers.VdiTock.Interval = 60000 / currentBpm / 3;&#10;            Timers.VdiTick.Enabled = true;&#10;            bpmInterval = CalculateBPMtoMS();&#10;        }&#10;&#10;        // Event handler nullability&#10;        private void ProcessTock(object? sender, ElapsedEventArgs e)&#10;        {&#10;            Dispatcher?.Dispatch(new VBITock(meterBoxModeNumeric));&#10;            Timers.VdiTock.Enabled = false;&#10;            UpdateVbi(VbiState?.Value.VBIStateNumber ?? 0);&#10;            this.StateHasChanged();&#10;        }&#10;&#10;        private TimeSpan UpdateRecentTime()&#10;        {&#10;            return currentTime - lastTime;&#10;        }&#10;&#10;        private void TestBeat()&#10;        {&#10;            JSRuntime.InvokeVoidAsync(&quot;playBeat&quot;);&#10;        }&#10;&#10;        // Event handler nullability&#10;        private void ProcessTick(object? sender, ElapsedEventArgs elapsedEventArgs)&#10;        {&#10;            if (AudibleState?.Value.Audible == true)&#10;            {&#10;                JSRuntime.InvokeVoidAsync(&quot;playBeat&quot;);&#10;            }&#10;            Dispatcher?.Dispatch(new VBITick(meterBoxModeNumeric));&#10;            UpdateVbi(VbiState?.Value.VBIStateNumber ?? 0);&#10;            this.StateHasChanged();&#10;            Timers.VdiTock.Enabled = true;&#10;        }&#10;&#10;        private async Task Reset()&#10;        {&#10;            StopTimer();&#10;&#10;            if (Timers.VdiTick != null)&#10;            {&#10;                Timers.VdiTick.Enabled = false;&#10;                Timers.VdiTick.Close();&#10;            }&#10;&#10;            if (Timers.VdiTock != null)&#10;            {&#10;                Timers.VdiTock.Enabled = false;&#10;                Timers.VdiTock.Close();&#10;            }&#10;&#10;            Dispatcher.Dispatch(new ResetAudible());&#10;            Dispatcher.Dispatch(new VBIResetAction());&#10;            UpdateVbi(VbiState.Value.VBIStateNumber);&#10;&#10;            currentCount = 0;&#10;            averageMs = 0;&#10;            bpmInterval = 0;&#10;            jitter = 0;&#10;&#10;            stability = 0;&#10;            bpmAverage10 = &quot;X&quot;;&#10;            bpmAverage15 = &quot;X&quot;;&#10;            bpmAverage20 = &quot;X&quot;;&#10;            await beatButton.FocusAsync();&#10;        }&#10;&#10;        private void StartTimer()&#10;        {&#10;            startTime = DateTime.Now;&#10;            Timers.BeatTimer = new Timer&#10;            {&#10;                Interval = 1000,&#10;                AutoReset = true&#10;            };&#10;            Timers.BeatTimer.Elapsed += ProcessSecond;&#10;            Timers.BeatTimer.Enabled = true;&#10;        }&#10;&#10;        private void ProcessSecond(object? sender, ElapsedEventArgs elapsedEventArgs)&#10;        {&#10;            elapsedSecond++;&#10;            StateHasChanged();&#10;        }&#10;&#10;        private void StopTimer()&#10;        {&#10;            if (Timers.BeatTimer != null &amp;&amp; Timers.BeatTimer.Enabled)&#10;            {&#10;                Timers.BeatTimer.Enabled = false;&#10;                Timers.BeatTimer.Stop();&#10;                Timers.BeatTimer.Close();&#10;            }&#10;&#10;            elapsedSecond = 0;&#10;            currentBpm = 0;&#10;            recentTimeMs = 0;&#10;        }&#10;&#10;        private void ToggleAudibleCheck()&#10;        {&#10;            Dispatcher.Dispatch(new ToggleAudible());&#10;            InvokeAsync(StateHasChanged);&#10;        }&#10;&#10;&#10;        private async Task HandleMeterUpdate(ChangeEventArgs arg)&#10;        {&#10;            meterBoxMode = (string) arg.Value;&#10;&#10;            meterBoxModeNumeric = meterBoxMode switch&#10;            {&#10;                &quot;VBI&quot; =&gt; 1,&#10;                &quot;2/4&quot; =&gt; 2,&#10;                &quot;3/4&quot; =&gt; 3,&#10;                &quot;4/4&quot; =&gt; 4,&#10;                _ =&gt; meterBoxModeNumeric&#10;            };&#10;&#10;            Dispatcher.Dispatch(new VBIResetAction());&#10;            UpdateVbi(VbiState.Value.VBIStateNumber);&#10;            await Task.CompletedTask;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Store/AudibleBeat/Reducers.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Store/AudibleBeat/Reducers.cs" />
              <option name="originalContent" value="using Fluxor;&#10;&#10;namespace HSTempoWasm.Store.AudibleBeat&#10;{&#10;    // Reducer for AudibleBeat state&#10;    public class AudibleBeatReducers&#10;    {&#10;        [ReducerMethod]&#10;        public static AudibleState ResetAudibleState(AudibleState state, ResetAudible action)&#10;        {&#10;            // Reset AudibleBeat state to default (false)&#10;            return new AudibleState(false);&#10;        }&#10;        &#10;        [ReducerMethod]&#10;        public static AudibleState ToggleAudibleState(AudibleState state, ToggleAudible action)&#10;        {&#10;            // Toggle AudibleBeat state&#10;            return new AudibleState(!state.Audible);&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using Fluxor;&#10;&#10;namespace HSTempoWasm.Store.AudibleBeat&#10;{&#10;    // Reducer for AudibleBeat state&#10;    public class AudibleBeatReducers&#10;    {&#10;        [ReducerMethod]&#10;        public AudibleState ResetAudibleState(AudibleState state, ResetAudible action)&#10;        {&#10;            // Reset state to default (false)&#10;            return new AudibleState(false);&#10;        }&#10;        &#10;        [ReducerMethod]&#10;        public AudibleState ToggleAudibleState(AudibleState state, ToggleAudible action)&#10;        {&#10;            // Toggle state&#10;            return new AudibleState(!state.Audible);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/Store/VBI/Reducers.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Store/VBI/Reducers.cs" />
              <option name="originalContent" value="using System;&#10;using Fluxor;&#10;&#10;namespace HSTempoWasm.Store.VBI&#10;{&#10;    public class Reducers&#10;    {&#10;        [ReducerMethod]&#10;        public static VBIState ResetAudibleState(VBIState state, VBIResetAction action)&#10;        {&#10;            return new VBIState(0);&#10;        }&#10;        &#10;        [ReducerMethod]&#10;        public static VBIState VBITick(VBIState state, VBITick action)&#10;        {&#10;            if (action.VBIMode == 1)&#10;            {&#10;                return new VBIState(5);&#10;            }&#10;            else&#10;            {&#10;                var meter = action.VBIMode;&#10;                return state.VBIStateNumber &lt; meter ? new VBIState(state.VBIStateNumber+1) : new VBIState(1);&#10;            }&#10;        }&#10;        &#10;        [ReducerMethod]&#10;        public static VBIState VBITock(VBIState state, VBITock action)&#10;        {&#10;            return action.VBIMode == 1 ? new VBIState(0) : new VBIState(state.VBIStateNumber);&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="using System;&#10;using Fluxor;&#10;&#10;namespace HSTempoWasm.Store.VBI&#10;{&#10;    // VBI state reducer&#10;    public class VBIReducers&#10;    {&#10;        private const int VbiModeSingle = 1;&#10;        private const int VbiTickValue = 5;&#10;&#10;        [ReducerMethod]&#10;        public static VBIState ResetVBIState(VBIState state, VBIResetAction action)&#10;        {&#10;            // Reset VBI state&#10;            return new VBIState(0);&#10;        }&#10;        &#10;        [ReducerMethod]&#10;        public static VBIState VBITick(VBIState state, VBITick action)&#10;        {&#10;            if (action.VBIMode == VbiModeSingle)&#10;            {&#10;                // Single mode: set to fixed value&#10;                return new VBIState(VbiTickValue);&#10;            }&#10;            else&#10;            {&#10;                var meter = action.VBIMode;&#10;                // If less than meter, increment; otherwise reset to 1&#10;                return state.VBIStateNumber &lt; meter ? new VBIState(state.VBIStateNumber+1) : new VBIState(1);&#10;            }&#10;        }&#10;        &#10;        [ReducerMethod]&#10;        public static VBIState VBITock(VBIState state, VBITock action)&#10;        {&#10;            // Single mode: reset to 0; otherwise keep current state&#10;            return action.VBIMode == VbiModeSingle ? new VBIState(0) : new VBIState(state.VBIStateNumber);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/TempoLogic.cs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/TempoLogic.cs" />
              <option name="updatedContent" value="namespace HSTempoWasm&#10;{&#10;    public static class TempoLogic&#10;    {&#10;        public static short CalculateBPMtoMS(double bpm)&#10;        {&#10;            return bpm &lt;= 0 ? (short)0 : Convert.ToInt16(Math.Round(60000 / bpm));&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>